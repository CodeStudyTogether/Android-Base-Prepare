RxJava是基于Java虚拟机上的响应式扩展库，它通过使用可观察的序列将异步和基于事件的程序组合起来。
与此同时，它扩展了观察者模式来支持数据/事件序列，并且添加了操作符，这些操作符允许你声明性地组合序列，同时抽象出要关注的问题：比如低级线程、同步、线程安全和并发数据结构等。

RxJava操作符的源码也是很不错的学习资源，特别是FlatMap、Zip等操作符的源码，有很多可以借鉴的地方，但是它们内部的实现比较复杂，限于篇幅，本文只讲解RxJava的订阅流程和线程切换原理。

首先，上面使用了Observable类的create()方法创建了一个被观察者

这里使用了worker进行调度ObserveOnObserver这个实现了Runnable的任务。worker就是在AndroidSchedulers.mainThread()中创建的，内部其实就是使用Handler进行线程切换的

HashMap还算是比较复杂的一个数据结构，尤其是在JDK1.8之后又引入了红黑树之后。

HashMap是基于hash算法实现的，也就是不同于数组，每次添加数据时，下标自增的操作，而是根据Key的hash值以及数组的长度计算出对应的下标，放入元素，那么在查找的时候就直接能够定位到对应的元素，如果在没有hash冲突的时候，时间复杂度基本就是O(1)了，引用一张图大致整体看下HashMap的数据结构。

当链表长度超过一定阈值时，直接进行数据结构转换，将链表转化成红黑树，红黑树是一种平衡二叉树，时间复杂度是O(logn)
  
HashMap的数据结构是由数组和链表（或树形结构）组成，所以本质还是由数组开始，我们知道数组是需要提前知道容量的，比如初始位10，那么当元素越来越多，因为下标范围是0-9，所以hash冲突会越来越多，这样形成很多链表或者树，查询时效率非常低，这时候就需要扩容了，也就是扩大原有数组的长度

HashMap底层数据结构由数组+链表+红黑树实现（JDK1.8），通过键key经过扰动函数扰动后得到hash值，然后再通过hash & (length - 1)代替取模的方式进行元素定位，查找效率最好情况是O(1)
  
当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程。

HashMap是非线程安全的，在多线程的操作下会存在异常情况，可以使用HashTable或者ConcurrentHashMap进行代替

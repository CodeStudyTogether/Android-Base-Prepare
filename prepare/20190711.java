在构造器中利用建造者模式来构建 OkHttpClient 的对象。

在 getResponseWithInterceptorChain() 方法中有一堆的拦截器！！！

拦截器是 OkHttp 的精髓。

最后在聚合了这些拦截器后，利用 RealInterceptorChain 来链式调用这些拦截器，利用的就是责任链模式。

多线程是为了使得多个线程并行的工作以完成多项任务，以提高系统的效率。线程是在同一时间需要完成多项任务的时候被实现的。

最佳方案：使用线程安全的对象是实现线程安全的。 java.util.concurrent包下的类。

比如 闭锁 CountDownLatch、ConcurrentHashMap、HashTable 、ThreadPoolExecutor 

Android中的广播使用了设计模式中的观察者模式：基于消息的发布 / 订阅事件模型

动态广播最好在Activity 的 onResume()注册、onPause()注销。

很多时候我们仅仅只是知道HashMap他是允许键值对都是Null，并且是非线程安全的，如果在多线程的环境下使用

我们都知道HashMap是数组+链表组成的，bucket数组是HashMap的主体，而链表是为了解决哈希冲突而存在的，但是很多人不知道其实HashMap是包含树结构的，但是得有一点 注意事项，什么时候会出现红黑树这种红树结构的呢？我们就得看源码了，源码解释说默认链表长度大于8的时候会转换为树。

之前看1.7的源码的时候，是没有这个红黑树的，而是在1.8 之后做了相应的优化。

我认为 IT 行业可以分为 互联网 和 传统软件 两个行业，虽然在外行人看来都是搞 IT 的，但业内人士都知道，这其中的差别可谓是天差地远。
在传统软件行业，对技术的要求其实很低，高性能基本不会涉及到，因为用户数量就那么点，TPS 都不用考虑。高可用大多数情况也不会涉及到，服务器停个 2 小时没啥关系，即便是有些场景，要求高可用，一般也就是双机热备就完事了。可扩展性，理论上是有要求的，实际上还不是前人挖坑后人填？这些公司面对的最大的技术问题恐怕还是业务的复杂性以及客户的认知，很多客户认为软件就是啥都能实现的，所以需求他们想怎么提就怎么提。
Code Review？大多数公司是没有的，老板也不关心代码的质量如何，验收能过就行。开发人员每天焦头烂额的都是满足客户各种无理的需求，以及无休止的需求变动。从上到下，谁也不会去关心你的代码是怎么写的。就算你变量定义成 fuck1、fuck2... 也无所谓。

6月18日下午，Facebook发布加密货币白皮书，正式推出加密货币项目Libra。
白皮书中讲到Libra的使命是建立一套简单的、无国界的货币和为数十亿人服务的金融基础设施。这一点与比特币类似，但是不同的是Libra看到了比特币等加密货币虽然名为加密货币但更像是一种投资资产，已经失去了货币的属性，所以Libra区块链中并没有挖矿的概念，而是采用储备。Libra的目标是成为一种稳定的数字加密货币，将全部使用真实资产储备（称为“Libra 储备”）作为担保，并由买卖Libra并存在竞争关系的交易平台网络提供支持。

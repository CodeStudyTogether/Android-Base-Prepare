看到源码默认的图片解码格式为ARGB_8888,和Picasso的默认格式相同了（貌似以前是RGB565）这个会多占内存了但是速度却快了，这需要牺牲空间换来换取更多的时间。

Glide.get(context)这里实际上是通过单例模式初始化Glide对象并赋值

builder.build内部通过构建者模式出创建实例

这个方法内部主要用于创建一个Fragment主要用来实现的Glide对Activity生命周期的感知作用（真是看了源码觉得fragment 还可以这样用）最终返回RequestManager。

RecyclerView使用四级缓存来进行视图的复用，缓存的逻辑主要集中在内部类Recycler中

mAttachedScrap--用于快速重用屏幕上可见的列表项ItemView，而不需要重新createView和bindViewmCachedViews--缓存离开屏幕的ItemView，目的是让即将进入屏幕的ItemView重用，使用这个缓存时不需要重新createView和bindViewmViewCacheExtension--不直接使用，用户定制的缓存mRecyclerPool--也是缓存离开屏幕的ItemView，但需要重新bindView

自定义缓存可以让用户自行设置缓存的策略
 
RecyclerView四级缓存：mAttachedScrap，mCachedViews，mViewCacheExtension，mRecyclerPoolmCachedViews 优先级高于 RecyclerViewPool，回收时，最新的 ViewHolder 都是往 mCachedViews 里放，如果它满了，那就移出一个扔到 ViewPool 里好空出位置来缓存最新的 ViewHolder。mAttachedScrap，mCachedViews取出来的均不需要重新bindView，而mRecyclerPool取出来的则需要进行bindView

使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或则“过度切换”的问题，归纳总结就是重用存在的线程，减少对象创建、消亡的开销，性能佳。可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。提供定时执行、定期执行、单线程、并发数控制等功能。

newCachedThreadPool：只有非核心线程，最大线程数非常大，所有线程都活动时会为新任务创建新线程,否则会利用空闲线程 ( 60s空闲时间,过了就会被回收,所以线程池中有0个线程的可能 )来处理任务.优点：任何任务都会被立即执行(任务队列SynchronousQuue相当于一个空集合);比较适合执行大量的耗时较少的任务.newFixedThreadPool：只有核心线程，并且数量固定的，所有线程都活动时，因为队列没有限制大小，新任务会等待执行，当线程池空闲时不会释放工作线程，还会占用一定的系统资源。优点：更快的响应外界请求newScheduledThreadPool：核心线程数固定,非核心线程（闲着没活干会被立即回收数）没有限制.优点：执行定时任务以及有固定周期的重复任务newSingleThreadExecutor：只有一个核心线程,确保所有的任务都在同一线程中按序完成优点：不需要处理线程同步的问题

Android中还了解哪些方便线程切换的类？
AsyncTask：底层封装了线程池和Handler，便于执行后台任务以及在子线程中进行UI操作。HandlerThread：一种具有消息循环的线程，其内部可使用Handler。IntentService：是一种异步、会自动停止的服务，内部采用HandlerThread。

IntentService可用于执行后台耗时的任务，当任务执行完成后会自动停止，同时由于IntentService是服务的原因，不同于普通Service，IntentService可自动创建子线程来执行任务，这导致它的优先级比单纯的线程要高，不容易被系统杀死，所以IntentService比较适合执行一些高优先级的后台任务。

HandlerThread：一个继承自Thread的类HandlerThread，Android中没有对Java中的Thread进行任何封装，而是提供了一个继承自Thread的类HandlerThread类，这个类对Java的Thread做了很多便利的封装。HandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，它在内部直接实现了Looper的实现，这是Handler消息机制必不可少的。有了自己的looper，可以让我们在自己的线程中分发和处理消息。如果不用HandlerThread的话，需要手动去调用Looper.prepare()和Looper.loop()这些方法。

产生ANR可能是因为5s内无响应用户输入事件、10s内未结束BroadcastReceiver、20s内未结束Service
想要避免ANR就不要在主线程做耗时操作，而是通过开子线程，方法比如继承Thread或实现Runnable接口、使用AsyncTask、IntentService、HandlerThread等

对于工具类或者需要写很多业务逻辑app，使用mvp或者mvvm都可。

AlertDialog、Notification源码中使用了Builder（建造者）模式完成参数的初始化Okhttp内部使用了责任链模式来完成每个Interceptor拦截器的调用RxJava的观察者模式；单例模式；GridView的适配器模式；Intent的原型模式日常开发的BaseActivity抽象工厂模式

日常开发的BaseActivity抽象工厂模式

所以可以通过static内部类+弱引用进行处理。由于本例是通过Retrofit进行，还可以在onDestory进行call.cancel进行取消任务，也可以避免内存泄漏。

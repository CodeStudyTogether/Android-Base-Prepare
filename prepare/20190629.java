看到源码默认的图片解码格式为ARGB_8888,和Picasso的默认格式相同了（貌似以前是RGB565）这个会多占内存了但是速度却快了，这需要牺牲空间换来换取更多的时间。

Glide.get(context)这里实际上是通过单例模式初始化Glide对象并赋值

builder.build内部通过构建者模式出创建实例

这个方法内部主要用于创建一个Fragment主要用来实现的Glide对Activity生命周期的感知作用（真是看了源码觉得fragment 还可以这样用）最终返回RequestManager。

RecyclerView使用四级缓存来进行视图的复用，缓存的逻辑主要集中在内部类Recycler中

mAttachedScrap--用于快速重用屏幕上可见的列表项ItemView，而不需要重新createView和bindViewmCachedViews--缓存离开屏幕的ItemView，目的是让即将进入屏幕的ItemView重用，使用这个缓存时不需要重新createView和bindViewmViewCacheExtension--不直接使用，用户定制的缓存mRecyclerPool--也是缓存离开屏幕的ItemView，但需要重新bindView

自定义缓存可以让用户自行设置缓存的策略
 
RecyclerView四级缓存：mAttachedScrap，mCachedViews，mViewCacheExtension，mRecyclerPoolmCachedViews 优先级高于 RecyclerViewPool，回收时，最新的 ViewHolder 都是往 mCachedViews 里放，如果它满了，那就移出一个扔到 ViewPool 里好空出位置来缓存最新的 ViewHolder。mAttachedScrap，mCachedViews取出来的均不需要重新bindView，而mRecyclerPool取出来的则需要进行bindView

使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或则“过度切换”的问题，归纳总结就是重用存在的线程，减少对象创建、消亡的开销，性能佳。可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。提供定时执行、定期执行、单线程、并发数控制等功能。

newCachedThreadPool：只有非核心线程，最大线程数非常大，所有线程都活动时会为新任务创建新线程,否则会利用空闲线程 ( 60s空闲时间,过了就会被回收,所以线程池中有0个线程的可能 )来处理任务.优点：任何任务都会被立即执行(任务队列SynchronousQuue相当于一个空集合);比较适合执行大量的耗时较少的任务.newFixedThreadPool：只有核心线程，并且数量固定的，所有线程都活动时，因为队列没有限制大小，新任务会等待执行，当线程池空闲时不会释放工作线程，还会占用一定的系统资源。优点：更快的响应外界请求newScheduledThreadPool：核心线程数固定,非核心线程（闲着没活干会被立即回收数）没有限制.优点：执行定时任务以及有固定周期的重复任务newSingleThreadExecutor：只有一个核心线程,确保所有的任务都在同一线程中按序完成优点：不需要处理线程同步的问题

Android中还了解哪些方便线程切换的类？
AsyncTask：底层封装了线程池和Handler，便于执行后台任务以及在子线程中进行UI操作。HandlerThread：一种具有消息循环的线程，其内部可使用Handler。IntentService：是一种异步、会自动停止的服务，内部采用HandlerThread。

IntentService可用于执行后台耗时的任务，当任务执行完成后会自动停止，同时由于IntentService是服务的原因，不同于普通Service，IntentService可自动创建子线程来执行任务，这导致它的优先级比单纯的线程要高，不容易被系统杀死，所以IntentService比较适合执行一些高优先级的后台任务。

HandlerThread：一个继承自Thread的类HandlerThread，Android中没有对Java中的Thread进行任何封装，而是提供了一个继承自Thread的类HandlerThread类，这个类对Java的Thread做了很多便利的封装。HandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，它在内部直接实现了Looper的实现，这是Handler消息机制必不可少的。有了自己的looper，可以让我们在自己的线程中分发和处理消息。如果不用HandlerThread的话，需要手动去调用Looper.prepare()和Looper.loop()这些方法。

产生ANR可能是因为5s内无响应用户输入事件、10s内未结束BroadcastReceiver、20s内未结束Service
想要避免ANR就不要在主线程做耗时操作，而是通过开子线程，方法比如继承Thread或实现Runnable接口、使用AsyncTask、IntentService、HandlerThread等

对于工具类或者需要写很多业务逻辑app，使用mvp或者mvvm都可。

AlertDialog、Notification源码中使用了Builder（建造者）模式完成参数的初始化Okhttp内部使用了责任链模式来完成每个Interceptor拦截器的调用RxJava的观察者模式；单例模式；GridView的适配器模式；Intent的原型模式日常开发的BaseActivity抽象工厂模式

日常开发的BaseActivity抽象工厂模式

所以可以通过static内部类+弱引用进行处理。由于本例是通过Retrofit进行，还可以在onDestory进行call.cancel进行取消任务，也可以避免内存泄漏。

继承系统控件View，例如：TextView、ImageView等
继承系统ViewGroup，例如LinearLayout、FrameLayout等（一般指自定义组合控件）
继承View，重写onMeasure()、onDraw()等，纯自己测量绘制
继承ViewGroup，重写onMeasure()、onLayout()，纯自己测量布局

Android 中的异步操作基本都是使用 Java 语言内置的，唯一的简单封装的异步类 AsyncTask 有几个主要回调

作者在封装 AsyncTask 这个类时多个任务是在一个后台线程中串行执行的，后来才意识到这样效率太低了就从 Android 1.6（API Level 4）开始改成并行执行了，但是从 Android 3.0（API Level 11）开始又改成默认串行执行了，Google 给的解释是为了避免并行执行可能带来的错误？？？如果你一定要并行执行，需要使用 executeOnExecutor() 方法并使用类似 AsyncTask.THREAD_POOL_EXECUTOR 这样的线程池去执行任务。

总结 AsyncTask初始化了一些参数，并用这些参数实例化了一个线程池THREAD_POOL_EXECUTOR，需要注意的是该线程池被定义为public static final，由此我们可以看出AsyncTask内部维护了一个静态的线程池，默认情况下，AsyncTask的实际工作就是通过该THREAD_POOL_EXECUTOR完成的。

总的来说AsyncTask的内部封装了SERIAL_EXECUTOR（排队线程池），THREAD_POOL_EXECUTOR（执行线程池），以WorkerRunnable为子线程封装可回调控制操作的FutureTask子线程，以及用于更新界面的一个内部InternalHandler

至少在Android-23 SDK里面，多个AsyncTask对象是串行执行的。

然后调用AsyncTask的executeOnExecutor，把自己的MyThreadPoolExecutor对象传进去，达到自己想要的效果。
不过，还是推荐使用系统默认的，也就是排队执行的方式，除非有特殊需求，我们才搞特殊化处理。

在Android3.0之前执行的时间是一样的，在Android3.0之后每个执行时间相差2秒

系统为了帮助开发者简化线程的切换问题，很人性化的提供了轻量级的AsyncTask。

AsyncTask作为一种轻量级的异步任务类，在Android开发过程中颇受开发者的喜爱。使用AsyncTaskNike 以在线程池中之行后台任务，并把之行的进度和最终结果传递给UI线程做进一步的操作。

AsyncTask作为一种轻量级的异步任务类，在Android开发过程中颇受开发者的喜爱。使用AsyncTaskNike 以在线程池中之行后台任务，并把之行的进度和最终结果传递给UI线程做进一步的操作。

大家都知道AsyncTask是一个抽象类，一般我们继承AsyncTask来创建我们的AsyncTask，而创建的时候我们需要提供三个泛型参数（～～||我怀疑我是不是在瞎逼逼了），
这三个泛型参数跟AsyncTask关系不浅哦。
1、Params：表示我们在调用execute方法时传递的参数类型
2、progress：表示后台任务的执行进度类型
3、Result：表示后台任务的返回结果类型。

AsyncTask执行execute方法时在Android1.6之前串行；Android1.6之后并行；Android3.0后串行

通过上面代码，我们知道，在执行AsyncTask的execute方法时，我们的线程默认是放入一个ArrayQueue队列中串行的执行的。也就是sDefaultExecutor是一个串行的执行器，所以我们的AsyncTask默认是串行自行的。

我们前面分析了，串行还是并行，关键是执行器。因为默认传入的是sDefaultExecutor，sDefaultExecutor是个串行的执行器，所以我们传入一个并行的执行器，是不是就可以了呢？

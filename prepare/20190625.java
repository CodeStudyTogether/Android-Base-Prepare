我们项目采用的是 kotlin && DataBinding 处理的，可能你会疑问，既然用的是 kotlin，为啥没有用 kotlinx？新的页面当然是用的 kotlinx 啦，但我们有相当庞大的历史代码，并且我们的通用 adapter 其实也是基于 DataBinding 来封装的。所以，我们还是不得不来讨(吐)论(槽)一下这个 DataBinding 的坑。

DataBinding 是早些时候 Google 推出来的一个支持库，只要勇于解决我们代码中频繁出现的 findViewById() 问题，在此之前，我相信大部分人都听过或者使用过 Butterknife，截止目前，该库都已经更新到 10.1.0 了，而且作者是 JakeWharton 大神，实为相当好用。

极难进行错误定位
代码极难维护

当我们提到 RxJava 时会想到什么，异步、事件流、响应式编程、观察者模式、链式编程等等。

看到很多文章都提到 RxJava 处理异步多么强大，各种线程切换的操作符很好地解决了 Android 上的主线程和子线程的数据传递。

所以尽量不要在频繁调用的函数中使用 RxJava。

在 RxJava 的世界里，一切其他事件都可以转化成 Observable 或者更准确的说是可观察者（如果考虑上 Single、Maybe、Flowable 等）。

上游不断地生产事件，然后下游一级一级地消费上游的事件。这在 Observable 上体现的不是很明显，可能用带流控的 Flowable 能更加说明这一点，上游不断地生产数据，往缓存池里放，下游则从缓存池中消费。

用 RxJava 的基本都知道观察者模式

1、第一次握手：客户端给服务器发送一个 SYN 报文。
2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。
3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。
4、服务器收到 ACK 报文之后，三次握手建立完成。

 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 
 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。  
 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

https://juejin.im/post/5d10c9626fb9a07ec63b20ee

如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。

四次挥手也一样，千万不要对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，我方一个 ACK 报文。

刚开始客户端处于 closed 的状态，服务端处于 listen 状态。

确认双方的接受能力、发送能力是否正常。

如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。

刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求

1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于CLOSED_WAIT1状态。
2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT2状态。
3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态

为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。

至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。

每次从MainActivity退出程序时总会报InputMethodManager内存泄漏，原因系统中的InputMethodManager持有当前MainActivity的引用，导致了MainActivity不能被系统回收，从而导致了MainActivity的内存泄漏。查了很多资料，发现这是 Android SDK中输入法的一个Bug，在15<=API<=23中都存在，目前Google还没有解决这个Bug。
